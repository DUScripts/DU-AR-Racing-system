{"slots":{"0":{"name":"receiver","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"system.print(\"SPEEDER chan/mess: \"..channel .. \" / \" ..message)\n\nif channel == tostring(player.getId()..\"R\") then\n    if message == \"upload\" and listening == false then\n        listening = true\n        emitter.send(tostring(player.getId())..\"S\",\"start upload\")\n        system.print(\"SPEEDER: starting download\")\n    elseif listening == true and message ~= \"upload\" and message ~= \"upload finished\" then\n        --system.print(\"SPEEDER: chunk received \"..message)\n        if previousUploadData ~= message then\n            uploadData = uploadData .. message\n            previousUploadData = uploadData\n            system.print(\"SPEEDER: chunk received \"..#uploadData)\n            \n        else\n            \n        end\n        emitter.send(tostring(player.getId())..\"S\",\"received\")\n        \n    elseif message == \"upload finished\" and listening == true then\n        system.print(\"SPEEDER final data: \"..#uploadData)\n        emitter.send(tostring(player.getId())..\"S\",\"end upload\")\n        local decodedData = deserialize(uploadData)\n        system.print(decodedData.circuitName)\n        system.print(decodedData.version)\n        --system.print(table.concat(decodedData.waypoints))\n        for i, v in ipairs(decodedData.waypoints) do \n            system.print(v)\n        end\n        local dbData = deserialize(DB.getStringValue(decodedData.circuitName))\n        if not dbData or dbData.version < decodedData.version then\n            system.print(\"Newer version of \"..decodedData.circuitName..\" dowloaded, erasing previous one\")\n            DB.setStringValue(decodedData.circuitName, uploadData)\n        end\n        --WP = convertWP(decodedData.waypoints)\n        listening = false\n        uploadData = \"\"\n        previousUploadData = nil\n        --script.onStart()\n    end\nend","filter":{"args":[{"variable":"*"},{"variable":"*"}],"signature":"onReceived(channel,message)","slotKey":"0"},"key":"0"},{"code":"circuitName = \"Hadron Island Cup\" --export: Name of the track in the databank.\n\nadmin = \"RyanPryde\" --export: give admin acces to map manual edition and chat commands\n\nmapScale = nil -- export: waypoints global scale\nmapOffset = nil -- export: on screen x and y waypoints offset\nmapRot = nil -- export: rotation of the waypoints in degrees\nimage = \"assets.prod.novaquark.com/102348/e78b385a-9129-49f5-96bd-9e81a2446e85.png\" --export: screen background image\nmapProximity = 15 --export: distance for grouping names on map in pixels \n\nomittedEntries = {\"Radar Race Map 1.4.14\",} --export: name of constructs to not display on the map\n\nlocal cF = nil -- export: fixed construct world forward {x,y,z} or nil, to be saved from a static construct\nlocal cR = nil -- export: fixed construct world right {x,y,z} or nil, to be saved from a static construct\nlocal cU = nil -- export: fixed construct world up {x,y,z} or nil, to be saved from a static construct\n\n----------------------------------------------------------------------------\n----------------------------------------------------------------------------\ncore = nil\nscreens = {}\nemitter = nil\nreceiver = nil\nDB = nil\nradar = nil\nlocal function findConnectedSlots()\n    local slot = {}\n    for slotName in pairs(unit) do\n        slot = unit[slotName]\n         if type(slot)=='table' and unit[slotName].getClass ~= nil and slotName~='system' and slotName~='library' and slotName~='unit' and slotName~='export' then\n            --system.print(slot.getElementClass())\n            if slot.getClass() == \"CoreUnitDynamic\" then\n                core = slot\n                system.print(\"Core found\")\n            end\n            if slot.getClass() == \"ScreenUnit\" then\n                screens[#screens+1] = slot\n                system.print(\"Screen found\")\n            end\n            if slot.getClass() == \"EmitterUnit\" then\n                emitter = slot\n                system.print(\"Emitter found\")\n            end\n            if slot.getClass() == \"ReceiverUnit\" then\n                receiver = slot\n                system.print(\"Receiver found\")\n            end \n            if slot.getClass() == \"DataBankUnit\" then\n                DB = slot\n                system.print(\"DataBank found\")\n            end\n            if slot.getClass() == \"RadarPvPAtmospheric\" then\n                radar = slot\n                system.print(\"Radar found\")\n            end\n        end\n    end\nend\nfindConnectedSlots()\nif core == nil or #screens == 0 or receiver == nil or DB == nil or radar == nil then system.print(\"All elements need to be connected!\") unit.exit()end\n\n-----------Receiverchannel setup----------------\nchannels = {tostring(player.getId())..\"R\"}\nif receiver then receiver.setChannelList(channels) end\n------------------------------------------------\n\nlocal cos, sin, max, min, sqrt, rad, match, toNum, abs = math.cos, math.sin, math.max, math.min, math.sqrt, math.rad, string.match, tonumber, math.abs\nlocal function convertToWorldCoordinates(posString)\n    local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n    local posPattern = '::pos{' .. num .. ',' .. num .. ',' .. num .. ',' .. num ..  ',' .. num .. '}'\n    local systemId, bodyId, latitude, longitude, altitude = match(posString,posPattern)\n    systemId = toNum(systemId)\n    bodyId = toNum(bodyId)\n    latitude = toNum(latitude)\n    longitude = toNum(longitude)\n    altitude = toNum(altitude)\n    if toNum(bodyId) == 0 then\n        return latitude,longitude,altitude\n    end\n    latitude = 0.0174532925199 * max(min(latitude, 90), -90)\n    longitude = 0.0174532925199 * (longitude % 360)\n    local center, radius = Helios[bodyId].center, toNum(Helios[bodyId].radius)\n    local xproj = cos(latitude)\n    local px, py, pz = center[1]+(radius+altitude) * xproj*cos(longitude),\n    center[2]+(radius+altitude) * xproj*sin(longitude),\n    center[3]+(radius+altitude) * sin(latitude)\n    return px, py, pz\nend\n\nlocal function dotVec(x1,y1,z1,x2,y2,z2)\n    return x1*x2 + y1*y2 + z1*z2\nend\n\n\nlocal function vectorLen(x,y,z)\n    return sqrt(x * x + y * y + z * z)\nend\n\nlocal function vectorLen2(x,y,z)\n\treturn x * x + y * y + z * z\nend\n\nlocal function projectOnPlane(x,y,z,pnx,pny,pnz) --pn = plane normal\n    local dot = dotVec(x,y,z,pnx,pny,pnz)\n    local len2 = vectorLen2(x,y,z)\n    return  x - (dot * pnx) / len2,\n            y - (dot * pny) / len2,\n            z - (dot * pnz) / len2\nend\n\nlocal function vectorScale(x,y,z,m)\n    return x*m, y*m, z*m\nend\n\nlocal function vectorDiv(x,y,z,m)\n    return x/m, y/m, z/m\nend\n\nlocal function rotateVec(vx, vy, vz, phi, ax, ay, az)\n    local l = sqrt(ax*ax + ay*ay + az*az)\n    local ux, uy, uz = ax/l, ay/l, az/l\n    local c, s = cos(phi), sin(phi)\n    local m1x, m1y, m1z = (c + ux * ux * (1-c)), (ux * uy * (1-c) - uz * s), (ux * uz * (1-c) + uy * s)\n    local m2x, m2y, m2z = (uy * ux * (1-c) + uz * s), (c + uy * uy * (1-c)), (uy * uz * (1-c) - ux * s)\n    local m3x, m3y, m3z = (uz * ux * (1-c) - uy * s), (uz * uy * (1-c) + ux * s), (c + uz * uz * (1-c))\n    return m1x*vx+m1y*vy+m1z*vz, m2x*vx+m2y*vy+m2z*vz, m3x*vx+m3y*vy+m3z*vz\nend\n\nsx, sy = 1024, 613\ndifMax = 0\nlocal convertWP = function(t) -- convert a table of pos to screen pos\n    local newT = {}\n    local x,y,z = 0,0,0\n    for i, v in ipairs(t) do --convert map coordinates to world coordinates\n        x,y,z = convertToWorldCoordinates(v)\n        newT[i] = {x,y,z} \n    end\n    for i, v in ipairs(newT) do --global to local\n        newT[i] = library.systemResolution3({cWORx, cWORy, cWORz},{cWOFx, cWOFy, cWOFz},{cWOUPx, cWOUPy, cWOUPz},{v[1], v[2], v[3]}) \n    end\n    \n    if xmin == nil then\n        for i, v in ipairs(newT) do --detemine size of the track\n            if xmin == nil then xmin = v[1] end\n            if xmax == nil then xmax = v[1] end\n            if v[1] <= xmin then xmin = v[1]\n            elseif v[1] >= xmax then xmax = v[1]\n            end\n            if ymin == nil then ymin = v[2] end\n            if ymax == nil then ymax = v[2] end\n            if v[2] <= ymin then ymin = v[2]\n            elseif v[2] >= ymax then ymax = v[2]\n            end\n        end\n        xmax = xmax - xmin\n        ymax = ymax - ymin\n    end\n    --system.print(xmin..\" / \"..ymin)\n    --system.print(xmax..\" / \"..ymax)\n    for i, v in ipairs(newT) do --offset coordinates to have all of them positive\n        newT[i][1] = newT[i][1]-xmin\n        newT[i][2] = newT[i][2]-ymin\n    end\n\n    --system.print(xmax..\" / \"..ymax)\n    difMax = math.max(xmax,ymax)\n    --system.print(difMax)\n    for i, v in ipairs(newT) do --rescale coordinates to fit into the screen\n        --system.print(v[1]..\" / \"..v[2])\n        x,y,z = vectorScale(v[1], v[2], v[3], 1/difMax)\n        --system.print(x..\" / \"..y)\n        x,y,z = vectorScale(x, y, z, sy*mapScale)\n        x,y,z = x+mapOffset[1], y+mapOffset[2] , z\n        newT[i] = {x,y,z}\n        \n        --system.print(x..\" / \"..y)\n    end\n    return newT\nend\n\nlistening = false\nuploadData = \"\"\npreviousUploadData = nil\n\nscript = {\n    onStart = function()\n        local mapParams = deserialize(DB.getStringValue(\"mapParams\"))\n        if mapParams then\n            mapScale = mapParams.mapScale\n            mapOffset = mapParams.mapOffset\n            mapRot = mapParams.mapRot\n        else\n            mapScale = mapScale or 1\n            mapOffset = mapOffset or {0,0}\n            mapRot = mapRot or 0\n        end\n        system.print(\"Map offset: \"..mapOffset[1]..\",\"..mapOffset[2])\n        system.print(\"Map rot: \"..mapRot)\n        system.print(\"Map scale: \"..mapScale)\n        \n        local orientationVec = deserialize(DB.getStringValue(\"oVectors\"))\n        local cWOUP = cU or (orientationVec ~= nil and orientationVec.cU) or construct.getWorldOrientationUp()\n        local cWOF = cF or (orientationVec ~= nil and orientationVec.cF) or construct.getWorldOrientationForward()\n        local cWOR = cR or (orientationVec ~= nil and orientationVec.cR) or construct.getWorldOrientationRight()\n        cWOUPx, cWOUPy, cWOUPz = cWOUP[1], cWOUP[2], cWOUP[3] --getConstructWorldOrientationUp\n        cWOFx, cWOFy, cWOFz = rotateVec(cWOF[1], cWOF[2], cWOF[3], rad(mapRot), cWOUP[1], cWOUP[2], cWOUP[3]) --getConstructWorldOrientationForward\n        cWORx, cWORy, cWORz = rotateVec(cWOR[1], cWOR[2], cWOR[3], rad(mapRot), cWOUP[1], cWOUP[2], cWOUP[3]) --getConstructWorldOrientationRight\n        cWORx, cWORy, cWORz = vectorScale(cWORx, cWORy, cWORz, -1)\n        if orientationVec == nil then\n            DB.setStringValue(\"oVectors\",serialize({cU = cWOUP, cF = cWOF, cR = cWOR}))\n            system.print(\"Saving new orientation vectors\")\n        end\n        \n        local dbKeys = DB.getKeyList()\n        system.print(\"--------------------------\")\n        system.print(\"Tracks found on Databank:\")\n        for k, v in pairs(dbKeys) do\n            if v ~= \"mapParams\" and v ~= \"oVectors\" then\n                system.print(\"- \"..v)\n            end\n        end\n        system.print(\"--------------------------\")\n\n        \n        if uploadData == \"\" and listening == false then\n            local decodedData = deserialize(DB.getStringValue(circuitName))\n            if decodedData and decodedData.waypoints then\n                local wpPos = decodedData.waypoints\n                WP = convertWP(wpPos) -- convert wpPos strings into world coordinates\n                --system.setWaypoint(wpPos[1],true)\n                --system.setWaypoint(\"::pos{0,0,\"..WP[1][1]..\",\"..WP[1][2]..\",\"..WP[1][3]..\"}\",true)\n                system.print(\"Databank circuit loaded: \"..circuitName)\n                system.print(\"Databank waypoints loaded: \"..#WP)\n                system.print(\"To change the circuit, change circuitName variable in external parameters!\")\n            else\n                system.print(\"No data found in databank for the circuit named: \"..circuitName)\n                --unit.exit()\n            end\n        end\n        initialized = true\n        listening = false\n        uploadData = \"\"\n        previousUploadData = nil\n        buildRender()\n        unit.setTimer(\"radar\",0.1)\n        for i, v in ipairs(screens) do\n            v.activate()\n            v.setRenderScript(screenScript)\n        end\n        \n    end,\n    \n    luaInput = function(text)\n        if text == \"reset params\" then\n            if DB.hasKey(\"map\") then\n                DB.clearValue(\"mapParams\")\n                system.print(\"Map settings has been reseted\")\n                unit.exit()\n            end\n        elseif string.sub(text,1,6)  == \"remove\" then\n            if DB.hasKey(string.sub(text,8,-1)) then\n                DB.clearValue(string.sub(text,8,-1))\n                system.print(\"Track \"..string.sub(text,8,-1)..\" has been deleted\")\n            end\n        elseif text == \"reset orientation\" then\n            if DB.hasKey(\"oVectors\") then\n                DB.clearValue(\"oVectors\")\n                system.print(\"Map orientation has been reseted\")\n                unit.exit()\n            end\n        elseif text == \"reset all\" then\n            DB.clear()\n            system.print(\"Databank has been completly reseted\")\n            unit.exit()\n        else\n            system.print(\"Chat commands are:\")\n            system.print(\"reset params\")\n            system.print(\"reset orientation\")\n            system.print(\"remove trackName\")\n            system.print(\"reset all\")\n        end\n    end,\n}\nscript.onStart()\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"1"},{"code":"local transponderData = {}\n\nlocal function vectorScale(x,y,z,m)\n    return x*m, y*m, z*m\nend\n\nlocal convertWP = function(t) -- convert a table of pos to screen pos\n    local x,y,z = 0,0,0\n    t = library.systemResolution3({cWORx, cWORy, cWORz},{cWOFx, cWOFy, cWOFz},{cWOUPx, cWOUPy, cWOUPz},{t[1], t[2], t[3]}) \n\n    t[1] = t[1]-xmin\n    t[2] = t[2]-ymin\n    \n    x,y,z = vectorScale(t[1], t[2], t[3], 1/difMax)\n    x,y,z = vectorScale(x, y, z, sy*mapScale)\n    x,y,z = x+mapOffset[1], y+mapOffset[2] , 0\n    t = {x,y,z}\n    return t\nend\n\nif radar ~= nil and  radar.getOperationalState() == 1 then\n    local concat = table.concat\n    local matchElementId = \"\"\n\n    local ind = 0\n    local getIds = radar.getConstructIds()\n    for k, v in pairs(getIds) do\n        local omit = false\n        for i, v2 in ipairs(omittedEntries) do\n            if radar.getConstructName(v) == v2 then omit = true end\n        end\n        if radar.hasMatchingTransponder(v) == true and omit == false then\n            ind = ind +1\n            local pos = convertWP(radar.getConstructWorldPos(v))\n            transponderData[ind] = {name = radar.getConstructName(v), pos = pos} \n        end \n    end\n    local d2S = serialize(transponderData)\n    for i, v in ipairs(screens) do\n        v.setScriptInput(d2S)\n    end\nend","filter":{"args":[{"value":"radar"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"2"},{"code":"--mapScale = 1.47 --export: waypoints global scale\n--mapOffset = {85, 15} --export: on screen x and y waypoints offset\n--mapRot = -90 --export: rotation of the waypoints in degrees\nif admin == player.getName() and player.isSeated() == true then\n    mapOffset[2] = mapOffset[2] - 1\n    system.print(\"Map offset: \"..mapOffset[1]..\",\"..mapOffset[2])\n    system.print(\"Map rot: \"..mapRot)\n    system.print(\"Map scale: \"..mapScale)\n    xmax = nil\n    xmin = nil\n    ymax = nil\n    ymin = nil\n    saveParams()\n    script.onStart()\nend","filter":{"args":[{"value":"forward"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"3"},{"code":"--mapScale = 1.47 --export: waypoints global scale\n--mapOffset = {85, 15} --export: on screen x and y waypoints offset\n--mapRot = -90 --export: rotation of the waypoints in degrees\nif admin == player.getName() and player.isSeated() == true then\n    mapOffset[2] = mapOffset[2] + 1\n    system.print(\"Map offset: \"..mapOffset[1]..\",\"..mapOffset[2])\n    system.print(\"Map rot: \"..mapRot)\n    system.print(\"Map scale: \"..mapScale)\n    xmax = nil\n    xmin = nil\n    ymax = nil\n    ymin = nil\n    saveParams()\n    script.onStart()\nend","filter":{"args":[{"value":"backward"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"4"},{"code":"--mapScale = 1.47 --export: waypoints global scale\n--mapOffset = {85, 15} --export: on screen x and y waypoints offset\n--mapRot = -90 --export: rotation of the waypoints in degrees\nif admin == player.getName() and player.isSeated() == true then\n    mapOffset[1] = mapOffset[1] - 1\n    system.print(\"Map offset: \"..mapOffset[1]..\",\"..mapOffset[2])\n    system.print(\"Map rot: \"..mapRot)\n    system.print(\"Map scale: \"..mapScale)\n    xmax = nil\n    xmin = nil\n    ymax = nil\n    ymin = nil\n    saveParams()\n    script.onStart()\nend","filter":{"args":[{"value":"yawleft"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"5"},{"code":"--mapScale = 1.47 --export: waypoints global scale\n--mapOffset = {85, 15} --export: on screen x and y waypoints offset\n--mapRot = -90 --export: rotation of the waypoints in degrees\nif admin == player.getName() and player.isSeated() == true then\n    mapOffset[1] = mapOffset[1] + 1\n    system.print(\"Map offset: \"..mapOffset[1]..\",\"..mapOffset[2])\n    system.print(\"Map rot: \"..mapRot)\n    system.print(\"Map scale: \"..mapScale)\n    xmax = nil\n    xmin = nil\n    ymax = nil\n    ymin = nil\n    saveParams()\n    script.onStart()\nend","filter":{"args":[{"value":"yawright"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"6"},{"code":"--mapScale = 1.47 --export: waypoints global scale\n--mapOffset = {85, 15} --export: on screen x and y waypoints offset\n--mapRot = -90 --export: rotation of the waypoints in degrees\nif admin == player.getName() and player.isSeated() == true then\n    mapScale = mapScale - 0.01\n    system.print(\"Map offset: \"..mapOffset[1]..\",\"..mapOffset[2])\n    system.print(\"Map rot: \"..mapRot)\n    system.print(\"Map scale: \"..mapScale)\n    xmax = nil\n    xmin = nil\n    ymax = nil\n    ymin = nil\n    saveParams()\n    script.onStart()\nend","filter":{"args":[{"value":"strafeleft"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"7"},{"code":"--mapScale = 1.47 --export: waypoints global scale\n--mapOffset = {85, 15} --export: on screen x and y waypoints offset\n--mapRot = -90 --export: rotation of the waypoints in degrees\nif admin == player.getName() and player.isSeated() == true then\n    mapScale = mapScale + 0.01\n    system.print(\"Map offset: \"..mapOffset[1]..\",\"..mapOffset[2])\n    system.print(\"Map rot: \"..mapRot)\n    system.print(\"Map scale: \"..mapScale)\n    xmax = nil\n    xmin = nil\n    ymax = nil\n    ymin = nil\n    saveParams()\n    script.onStart()\nend","filter":{"args":[{"value":"straferight"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"8"},{"code":"--mapScale = 1.47 --export: waypoints global scale\n--mapOffset = {85, 15} --export: on screen x and y waypoints offset\n--mapRot = -90 --export: rotation of the waypoints in degrees\nif admin == player.getName() and player.isSeated() == true then\n    mapRot = mapRot - 0.5\n    system.print(\"Map offset: \"..mapOffset[1]..\",\"..mapOffset[2])\n    system.print(\"Map rot: \"..mapRot)\n    system.print(\"Map scale: \"..mapScale)\n    xmax = nil\n    xmin = nil\n    ymax = nil\n    ymin = nil\n    saveParams()\n    script.onStart()\nend","filter":{"args":[{"value":"left"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"9"},{"code":"--mapScale = 1.47 --export: waypoints global scale\n--mapOffset = {85, 15} --export: on screen x and y waypoints offset\n--mapRot = -90 --export: rotation of the waypoints in degrees\nif admin == player.getName() and player.isSeated() == true then\n    mapRot = mapRot + 0.5\n    system.print(\"Map offset: \"..mapOffset[1]..\",\"..mapOffset[2])\n    system.print(\"Map rot: \"..mapRot)\n    system.print(\"Map scale: \"..mapScale)\n    xmax = nil\n    xmin = nil\n    ymax = nil\n    ymin = nil\n    saveParams()\n    script.onStart()\nend","filter":{"args":[{"value":"right"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"10"},{"code":"if admin == player.getName() then\n    script.luaInput(text)\nend","filter":{"args":[{"variable":"*"}],"signature":"onInputText(text)","slotKey":"-4"},"key":"11"},{"code":"local concat = table.concat\n\nlocal function internalSerialize(table, tC, t)\n    t[tC] = \"{\"\n    tC = tC + 1\n    if #table == 0 then\n        local hasValue = false\n        for key, value in pairs(table) do\n            hasValue = true\n            local keyType = type(key)\n            if keyType == \"string\" then\n                t[tC] = key .. \"=\"\n            elseif keyType == \"number\" then\n                t[tC] = \"[\" .. key .. \"]=\"\n            elseif keyType == \"boolean\" then\n                t[tC] = \"[\" .. tostring(key) .. \"]=\"\n            else\n                t[tC] = \"notsupported=\"\n            end\n            tC = tC + 1\n\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = '\"' .. value .. '\"'\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        if hasValue then\n            tC = tC - 1\n        end\n    else\n        for i = 1, #table do\n            local value = table[i]\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = '\"' .. value .. '\"'\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        tC = tC - 1\n    end\n    t[tC] = \"}\"\n    return tC\nend\n\nfunction serialize(value)\n    local t = {}\n    local check = type(value)\n\n    if check == \"table\" then\n        internalSerialize(value, 1, t)\n    elseif check == \"string\" then\n        return '\"' .. value .. '\"'\n    elseif check == \"number\" then\n        return value\n    elseif check == \"boolean\" then\n        return tostring(value)\n    else\n        return '\"Not Supported\"'\n    end\n\n    return concat(t)\nend\n\nfunction deserialize(s)\n    return load(\"return \" .. s)()\nend\n\nfunction saveParams()\n    DB.setStringValue(\"mapParams\",serialize({mapOffset = mapOffset, mapScale = mapScale, mapRot = mapRot}))\nend\n\n\nserializer = [[local concat = table.concat\n\nlocal function internalSerialize(table, tC, t)\n    t[tC] = \"{\"\n    tC = tC + 1\n    if #table == 0 then\n        local hasValue = false\n        for key, value in pairs(table) do\n            hasValue = true\n            local keyType = type(key)\n            if keyType == \"string\" then\n                t[tC] = key .. \"=\"\n            elseif keyType == \"number\" then\n                t[tC] = \"[\" .. key .. \"]=\"\n            elseif keyType == \"boolean\" then\n                t[tC] = \"[\" .. tostring(key) .. \"]=\"\n            else\n                t[tC] = \"notsupported=\"\n            end\n            tC = tC + 1\n\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = '\"' .. value .. '\"'\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        if hasValue then\n            tC = tC - 1\n        end\n    else\n        for i = 1, #table do\n            local value = table[i]\n            local check = type(value)\n            if check == \"table\" then\n                tC = internalSerialize(value, tC, t)\n            elseif check == \"string\" then\n                t[tC] = '\"' .. value .. '\"'\n            elseif check == \"number\" then\n                t[tC] = value\n            elseif check == \"boolean\" then\n                t[tC] = tostring(value)\n            else\n                t[tC] = '\"Not Supported\"'\n            end\n            t[tC + 1] = \",\"\n            tC = tC + 2\n        end\n        tC = tC - 1\n    end\n    t[tC] = \"}\"\n    return tC\nend\n\nfunction serialize(value)\n    local t = {}\n    local check = type(value)\n\n    if check == \"table\" then\n        internalSerialize(value, 1, t)\n    elseif check == \"string\" then\n        return '\"' .. value .. '\"'\n    elseif check == \"number\" then\n        return value\n    elseif check == \"boolean\" then\n        return tostring(value)\n    else\n        return '\"Not Supported\"'\n    end\n\n    return concat(t)\nend\n\nfunction deserialize(s)\n    return load(\"return \" .. s)()\nend]]","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"12"},{"code":"function buildRender()\n    screenScript = serializer..[[ \n    BG = createLayer()\n    layer = createLayer()\n    radar = createLayer()\n    image = loadImage(\"]]..image..[[\")\n    font_size = 40\n    font = loadFont('TurretRoad', font_size)\n    font_size_mini = 14\n    font_mini = loadFont('Montserrat-Light', font_size_mini)\n    \n    --WP circles\n    setDefaultFillColor(layer, 3, 0, 0, 0, 0)\n    setDefaultStrokeWidth(layer, 3, 1)\n    setDefaultStrokeColor(layer, 3, 1, 1, 1, 1)\n    \n    --WP lines\n    setDefaultFillColor(layer, 5, 0, 0, 0, 0)\n    setDefaultStrokeWidth(layer, 5, 1)\n    setDefaultStrokeColor(layer, 5, 1, 1, 1, 1)\n    \n    --players circles\n    setDefaultFillColor(radar, 3, 1, 0, 0, 1)\n    setDefaultStrokeWidth(radar, 3, 1)\n    setDefaultStrokeColor(radar, 3, 0, 0, 0, 1)\n    \n    --players text\n    setDefaultFillColor(radar, 7, 1, 1, 1, 1)\n    setDefaultStrokeWidth(radar, 7, 1)\n    setDefaultStrokeColor(radar, 7, 0, 0, 0, 1)\n    setDefaultTextAlign(radar, AlignH_Center, AlignV_Middle)\n    \n    addText(layer,font,\"]]..circuitName..[[\",650,550)\n    \n    setBackgroundColor(0, 0.15, 0.4) -- background colour\n    setNextFillColor(BG, 1, 1, 1, 1) --background image adjust\n    addImage(BG,image,0,0,1024,613) --background image\n    \n    input = deserialize(getInput()) or {} -- get the input from programmboard\n    \n    --name / pos --pos is screen coordinates\n    ]]\n    \n    if WP then\n        local nWP = #WP \n        for i, v in ipairs(WP) do\n            local nx = i < nWP and math.floor(WP[i+1][1]) or math.floor(WP[1][1])\n            local ny = i < nWP and math.floor(WP[i+1][2]) or math.floor(WP[1][2])\n            screenScript = screenScript..[[addLine(layer, ]]..math.floor(v[1])..[[, ]]..math.floor(v[2])..[[, ]]..nx..[[, ]]..ny..[[) ]]\n        end\n        for i, v in ipairs(WP) do\n            if i == 1 then screenScript = screenScript..[[setNextFillColor(layer,1,0,0,1) ]] end\n            screenScript = screenScript..[[addCircle(layer, ]]..math.floor(v[1])..[[, ]]..math.floor(v[2])..[[, 8) ]]\n        end\n    end\n    \n    screenScript = screenScript..[[\n    \n    function stringToTable(String, Separator)\n        local Separator = Separator or ','\n        local axes = {}\n        for axis in String:gmatch('[^'..Separator..']+') do\n            axes[#axes + 1] = axis\n        end\n        return axes\n    end\n    local sqrt, abs = math.sqrt, math.abs\n    local vec2Dist = function(x1,y1,x2,y2)\n        return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))\n    end\n    \n    local yOffset = 15\n    local addedPoints = {}\n    local newInput = {}\n    --------------Radar data-----------------\n    for i, v in ipairs(input) do\n        local overlapOffset = 0\n        local cName = v.name --string name\n        local cPos = v.pos --table x=cPos[1] y =cPos[2]\n        --format lua rendering here\n            \n        addCircle(radar, cPos[1], cPos[2], 5)\n\n        local group = false\n        local ind = 0\n        for i2, v2 in ipairs(newInput) do\n            local vPos = v2.pos\n            if abs(vec2Dist(cPos[1], cPos[2], vPos[1], vPos[2])) < ]]..mapProximity..[[ then\n                group = true\n                ind = i2\n                break\n            end\n        end\n        if group == true then\n            newInput[ind].text = newInput[ind].text..\",\"..cName\n        else\n            newInput[#newInput+1] = {pos = cPos, text = cName}\n        end\n        \n        --addText(radar, font_mini, cName,  cPos[1], cPos[2]+yOffset+overlapOffset)\n    end\n    for i, v in ipairs(newInput) do\n        local cName = v.text\n        local cPos = v.pos\n        local s2T = stringToTable(cName, \",\")\n        for i2, v2 in ipairs(s2T) do\n            addText(radar, font_mini, v2,  cPos[1], cPos[2]+yOffset+(i2-1)*yOffset)\n        end\n    end\n    --------------Radar data-----------------\n    requestAnimationFrame(1)]]\nend\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-5"},"key":"13"}],"methods":[],"events":[]}
